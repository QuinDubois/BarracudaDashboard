import pathlib
import dash
import json
from dash import dcc
from dash import html
import pandas as pd
from dash.dependencies import Input, Output, State
import plotly_express as px
import plotly.graph_objects as go
from app import app
from app import server
import numpy as np
from urllib.request import urlopen
from Barracuda_Processing import control_sort
from Barracuda_Plotting import default_chart, plot_control, plot_choropleth

# # Load data
APP_PATH = str(pathlib.Path(__file__).parent.resolve())

DEFAULT_OPACITY = 0.8

COLOR_STYLES = {
    "chart_background": "#E6E4E6",
    "chart_grid": "#B3B1B3",
    "tick_font": "#111111",
    "font": "#111111",
    "line_colors": [
        "#21A0A6"
    ],
    "marker_colors": [
        "#FAEA48",
        "#c47e0e",
        "#4951de",
        "#bd51c9",
        "#4cbf39",
        "#c95034",
    ]
}

# set mapbox token and style
mapbox_access_token = "pk.eyJ1IjoicGxvdGx5bWFwYm94IiwiYSI6ImNrOWJqb2F4djBnMjEzbG50amg0dnJieG4ifQ.Zme1-Uzoi75IaFbieBDl3A"
mapbox_style = "mapbox://styles/plotlymapbox/cjvprkf3t1kns1cqjxuxmwixz"

# This is the dev branch

# TODO: Fix bugs and add reverse geocoding and automatic field detection to dataJSONgen.py


# TODO: Rework file loading process and dataframe structure.
#   /   - Frames should have Spatial and Temporal data.
#   /   - Spatial Frame data can either be one dimensional (fips), or two dimensional (lat/long)
#   /   - Currently the dashboard accepts Annual Temporal data.
#   /
#   /   - Data within the Frame then should populate the data-selector dropdown. (it is currently hard coded)
#   /
#   /   - Chosen solution: Hard code each dataframe because lazyloading makes it more efficient.
#   /       - When adding a new frame to the dashboard a separate JSON file is included to handle the
#   /           field names and descriptions for the data-selector dropdown as well as key fields.
#   /   - Datasets must be present in the JSON otherwise they will not show up in the Dashboard.


# TODO: Refactor some ID and variable names
#   - some callback variables and html element ids are ambiguous.


# read in fips shape data
file = open("data/geojson-counties-fips.json")
counties = json.load(file)

### Dataset Loader
###     - A new line needs to be added here when a new dataset is added to the dashboard
#############################################################################
# read in climate data
data_annual_climate = "data/output.csv"
df_annual_climate = pd.read_csv(data_annual_climate, dtype={'fips': str})

# read in kestral range shift data
data_kestral_model = "data/kestralModel.csv"
df_kestral_model = pd.read_csv(data_kestral_model)

# read in carya ovata range shift data
data_carya_ovata = "data/Carya_ovata.csv"
df_carya_ovata = pd.read_csv(data_carya_ovata)

data_carya_ovata_spacetime = "data/carya_ovata_10km.csv"
df_carya_ovata_spacetime = pd.read_csv(data_carya_ovata_spacetime)
#############################################################################


### Data Field Filter
#############################################################################
# TODO: Complete New Dynamic Data Field Label and Filter Functionality
#   - Receive Dataset information from dataset_names.json generated by dataJSONgen.py
#   - Data fields dropdown will be filtered by Datasets dropdown.
#       - this resolves potential duplicate column conflicts.
#   - Will be able to identify datasets based on whether it has fips data or lat/long data
#       to make processing easier.
data_json_path = "data/dataset-names.json"
data_json_dict = {}
try:
    with open(data_json_path) as json_file:
        data_json_dict = json.load(json_file)
except json.JSONDecodeError as error:
    print(">>> ERROR Loading JSON: JSON empty or invalid structure. Dataframe Selectors will not work properly! <<<")
    data_json_dict = {}
except FileNotFoundError as error:
    print(
        ">>> ERROR Loading JSON: JSON " + data_json_path + " does not exist. Dataframe Selectors will not work properly! <<<")
    data_json_dict = {}

datasetOpts = []

for key in data_json_dict.keys():
    datasetOpts.append(
        {'label': data_json_dict[key]['dataset_label'],
         'value': key}
    )
#############################################################################


# flags for sorting the selected data
data_styles = {
    "base": [COLOR_STYLES["line_colors"][0], 1],
    "above average": [COLOR_STYLES["marker_colors"][0], 1],
    "below average": [COLOR_STYLES["marker_colors"][1], 1],
    "deviation above": [COLOR_STYLES["marker_colors"][2], 1],
    "deviation below": [COLOR_STYLES["marker_colors"][3], 1],
    "trending up": [COLOR_STYLES["marker_colors"][4], 1],
    "trending down": [COLOR_STYLES["marker_colors"][5], 1]
}

flags_opts = []
for key in data_styles:
    flags_opts.append({'label': key, 'value': key})

#######################################################################################################################


# This is my app layout
#######################################################################################################################
app.layout = html.Div(
    id="root",
    children=[
        html.Div(
            id="header",
            children=[
                html.A(
                    html.Img(id="logo", src=app.get_asset_url("barracuda_logo_final.png")),
                    href="https://www.uvm.edu/",
                ),
                html.H4(children=" Barracuda Data Visualization Dashboard"),
                html.P(
                    id="description",
                    children="Biodiversity and Rural Response to Climate Change Using Data Analysis",
                ),
            ],
        ),

        # App Container
        html.Div(
            id="app-container",
            children=[

                # Top row
                html.Div(
                    id="top-row",
                    children=[

                        # Left panel
                        html.Div(
                            id="choropleth-container",
                            children=[
                                html.Div(
                                    id="dropdown-container",
                                    children=[

                                        # Dataframe Selector Dropdown
                                        html.P(id="dataframe-selector", children="Select a Dataset"),
                                        dcc.Dropdown(
                                            options=datasetOpts,
                                            value='output.csv',
                                            id="dataframe-dropdown"
                                        ),

                                        # Data Selector Dropdown
                                        html.P(id="data-selector", children="Select a Variable to Plot"),
                                        dcc.Dropdown(
                                            options=[
                                                {
                                                    "label": "Average of Nighttime Minimum Temperature, (deg. C)",
                                                    "value": "tmin",
                                                },
                                                {
                                                    "label": "Average of Daytime High Temperature, (deg. C)",
                                                    "value": "tmax",
                                                },
                                                {
                                                    "label": "Average of Daily Mean Temperature, (deg. C)",
                                                    "value": "tmean",
                                                },
                                                {
                                                    "label": "Total Annual Precipitation, (mm)",
                                                    "value": "prec",
                                                },
                                                {
                                                    "label": "Total April Precipitation, (mm)",
                                                    "value": "aprec",
                                                },
                                                {
                                                    "label": "Length of Frost Free Period, (days)",
                                                    "value": "ffp",
                                                },
                                            ],
                                            value="tmin",
                                            id="data-dropdown",
                                        ),
                                    ],
                                ),

                                # Choropleth Chart
                                html.Div(
                                    id="heatmap-container",
                                    children=[
                                        html.P(
                                            "Heatmap Over Time (Select Year Below Map)",
                                            id="heatmap-title",
                                        ),
                                        dcc.Graph(
                                            id="county-choropleth",
                                            figure=dict(
                                                layout=dict(
                                                    mapbox=dict(
                                                        layers=[],
                                                        accesstoken=mapbox_access_token,
                                                        style=mapbox_style,
                                                        center=dict(
                                                            lat=38.72490, lon=-95.61446
                                                        ),
                                                        pitch=0,
                                                        zoom=3.5,
                                                    ),
                                                    autosize=True,
                                                ),
                                            ),
                                        ),
                                    ],
                                ),

                                # Year Selector Slider
                                html.Div(
                                    id="year-container",
                                    children=[
                                        html.P(id="year-selector", children="Select a Year to Plot"),
                                        dcc.Slider(
                                            value=1950,
                                            min=1950,
                                            max=2019,
                                            step=1,
                                            marks={
                                                1950: {'label': '1950'},
                                                1967: {'label': '1967'},
                                                1985: {'label': '1985'},
                                                2002: {'label': '2002'},
                                                2019: {'label': '2019'},
                                            },
                                            tooltip={"placement": "bottom", "always_visible": True},
                                            id="year-slider",
                                        ),
                                    ], style={'display': 'block'},
                                ),

                            ],
                        ),

                        # Top Right, Graph Container
                        html.Div(
                            id="graph-container",
                            children=[

                                # Chart Swapper
                                html.Div(
                                    children=[
                                        dcc.Dropdown(
                                            options=[
                                                {
                                                    "label": "Line Chart",
                                                    "value": "linechart",
                                                },
                                                {
                                                    "label": "Control Chart",
                                                    "value": "controlchart",
                                                },
                                                {
                                                    "label": "Statespace Chart",
                                                    "value": "statespace",
                                                },
                                            ],
                                            value="linechart",
                                            id="chart-swapper",
                                        ),
                                    ],
                                ),

                                # Aggregation Selector
                                html.P(id="aggregation-selector", children="Select summary statistic to plot:"),
                                dcc.Dropdown(
                                    options=[
                                        {
                                            "label": "Mean Value",
                                            "value": "mean",
                                        },
                                        {
                                            "label": "Median Value",
                                            "value": "median",
                                        },
                                        {
                                            "label": "Min. Value",
                                            "value": "min",
                                        },
                                        {
                                            "label": "Max. Value ",
                                            "value": "max",
                                        },
                                    ],
                                    value="mean",
                                    id="aggregation-dropdown",
                                ),
                                html.P(id="controls-text",
                                       children="Control options are below charts.",
                                       style={'display': 'none'}),

                                # Line Chart
                                dcc.Graph(
                                    className="top-right-panel-graph",
                                    id="selected-data",
                                    figure=dict(
                                        data=[dict(x=0, y=0)],
                                        layout=dict(
                                            paper_bgcolor="#F4F4F8",
                                            plot_bgcolor="#F4F4F8",
                                            autofill=True,
                                            margin=dict(t=75, r=50, b=100, l=50),
                                        ),
                                    ),
                                    style={'display': 'block'}
                                ),

                                # Control Chart
                                dcc.Graph(
                                    className="top-right-panel-graph",
                                    id="selected-control-data",
                                    figure=dict(
                                        data=[dict(x=0, y=0)],
                                        layout=dict(
                                            paper_bgcolor="#F4F4F8",
                                            plot_bgcolor="#F4F4F8",
                                            autofill=True,
                                            margin=dict(t=75, r=50, b=100, l=50),
                                        ),
                                    ),
                                    style={'display': 'none'}
                                ),

                                # State-space Chart
                                dcc.Graph(
                                    className="top-right-panel-graph",
                                    id="selected-statespace-data",
                                    figure=dict(
                                        data=[dict(x=0, y=0)],
                                        layout=dict(
                                            paper_bgcolor="#F4F4F8",
                                            plot_bgcolor="#F4F4F8",
                                            autofill=True,
                                            margin=dict(t=75, r=50, b=100, l=50),
                                        ),
                                    ),
                                    style={'display': 'none'}
                                ),

                            ],
                        ),
                    ],
                ),

                # Bottom Row
                html.Div(
                    id="bottom-row",
                    children=[
                        html.Div(className="hidden", children=[]),

                        # Controls container
                        html.Div(
                            id="control-container",
                            children=[
                                html.H4(children="Chart Display Options: "),
                                html.Div(className="slider-box", children=[
                                    html.P(className="control_title",
                                           children="Display outlying values by deviation amount:"),
                                    dcc.Slider(
                                        id='deviation-slider',
                                        value=1,
                                        min=1,
                                        max=3,
                                        step=1,
                                        marks={
                                            0: {'label': '0'},
                                            1: {'label': '1'},
                                            2: {'label': '2'},
                                            3: {'label': '3'}
                                        },
                                        tooltip={'placement': 'bottom', 'always_visible': True}
                                    ),
                                ]),
                                html.Div(className="slider-box", children=[
                                    html.P(className="control_title",
                                           children="Minimum amount of years for a trend to occur:"),
                                    dcc.Slider(
                                        id='trend-slider',
                                        value=10,
                                        min=2,
                                        max=20,
                                        step=1,
                                        marks={
                                            2: {'label': '2'},
                                            10: {'label': '10'},
                                            20: {'label': '20'}
                                        },
                                        tooltip={'placement': 'bottom', 'always_visible': True}
                                    ),
                                ]),
                                html.Div(className="control-box", children=[
                                    html.P(className="control_title", children="Select which markers to display:"),
                                    dcc.Checklist(
                                        id='flag-checklist',
                                        options=flags_opts[1:],
                                        value=list(data_styles.keys())[1:],
                                        labelStyle={'display': 'block'}
                                    ),
                                ]),
                                html.Div(children=[
                                    html.P(className="control_title", children="Display non-significant trend lines:"),
                                    dcc.Checklist(
                                        id='all-trend-checklist',
                                        options=[{'label': 'True',
                                                  'value': 'true'}],
                                        value=[],
                                        labelStyle={'display': 'inline'}
                                    ),
                                ]),
                            ],
                        )
                    ],
                    style={'display': 'none'}
                )
            ],
        ),
    ],
)
#######################################################################################################################

'''
Below are the Callbacks for updating elements when the user interacts with the dashboard.

update_year_slider_visibility - Updates the visibility of the year slider based on the spatial data type of the 
                                dataset. Datasets with county level data need a manual slider, while 
                                latitude/longitude centric datasets have an animated slider built in. 
                                
                  display_map - Updates the choropleth chart with the selected data.
                                
        display_selected_data - Updates the plot charts using the data selected on the choropleth chart.
                                
                 change_panel - Updates the panel containing the plots to display the currently selected plot.
                                
         update_data_selector - Updates the variable selector dropdown with the relevant variables present in the
                                chosen dataset.
'''


#######################################################################################################################
# Update Year Slider visibility, county based datasets need a manual slider.
@app.callback(
    Output(component_id='year-container', component_property='style'),
    [
        Input(component_id='dataframe-dropdown', component_property='value')
    ]
)
def update_year_slider_visibility(visibility_state):
    if data_json_dict[visibility_state]['space_type'] == 'latlong':
        return {'display': 'none'}


# Callback for Cloropleth figure
@app.callback(
    Output("county-choropleth", "figure"),
    [
        State("county-choropleth", "figure"),
        Input("data-dropdown", "value"),
        Input("dataframe-dropdown", "value"),
        Input("year-slider", "value"),
    ],
)
def display_map(figure, data_dropdown, dataframe_dropdown, year_slider):
    map_dat = select_dataframe(dataframe_dropdown)
    fig = plot_choropleth(
        figure, map_dat, dataframe_dropdown, data_dropdown, data_json_dict, COLOR_STYLES, year_slider, counties
    )

    return fig


# Update the other charts using the data selected in the choropleth.
@app.callback(
    [
        Output("selected-data", "figure"),
        Output('selected-control-data', 'figure'),
        Output('selected-statespace-data', 'figure'),
    ],
    [
        Input("county-choropleth", "selectedData"),
        Input("aggregation-dropdown", "value"),
        Input("data-dropdown", "value"),
        Input("dataframe-dropdown", "value"),
        Input("trend-slider", "value"),
        Input("deviation-slider", "value"),
        Input("flag-checklist", "value"),
        Input("all-trend-checklist", "value"),
        State("data-dropdown", "options"),
    ],
)
def display_selected_data(selected_data, chart_dropdown, data_dropdown, dataframe_dropdown, trend, deviation,
                          flag_checklist,
                          all_trends, opts):
    if selected_data is None:
        fig = default_chart(COLOR_STYLES)
        return fig, fig, fig

    chart_dat = select_dataframe(dataframe_dropdown)
    yval = data_dropdown
    lat_val = data_json_dict[dataframe_dropdown]['space_keys'][0]
    lon_val = data_json_dict[dataframe_dropdown]['space_keys'][1]
    time_val = data_json_dict[dataframe_dropdown]['temporal_key']

    # find points from the selected data
    pts = selected_data["points"]

    the_label = [x['label'] for x in opts if x['value'] == data_dropdown]

    the_label = str(the_label).replace('[', '').replace(']', '')

    if data_json_dict[dataframe_dropdown]["space_type"] == 'latlong':

        latVals = [d["lat"] for d in pts if "lat" in d]
        lonVals = [d["lon"] for d in pts if "lon" in d]

        vals = list(zip(latVals, lonVals))

        # find the values for all selected counties for all years
        df = chart_dat.set_index([lat_val, lon_val], drop=False)

        subDF = df.loc[df.index.isin(vals)]

    else:
        fips_val = data_json_dict[dataframe_dropdown]['space_keys'][2]
        # yval = data_dropdown

        # get a list of all locations selected
        vals = [d['location'] for d in pts if 'location' in d]

        # find the values for all selected counties for all years
        df = chart_dat.set_index([fips_val])
        subDF = df.loc[df.index.isin(vals)]

    if subDF.empty:
        fig = default_chart(COLOR_STYLES)
        return fig, fig, fig

    # select the data to plot
    ##########################################################################################
    if chart_dropdown == "mean":
        # summmary by time
        summDF = subDF.groupby(time_val).mean().reset_index()

    if chart_dropdown == "median":
        # summmary by time
        summDF = subDF.groupby(time_val).median().reset_index()

    if chart_dropdown == "min":
        # summmary by time
        summDF = subDF.groupby(time_val).min().reset_index()

    if chart_dropdown == "max":
        # summmary by time
        summDF = subDF.groupby(time_val).max().reset_index()
    ##########################################################################################

    # Line Chart Figure
    ##########################################################################################
    fig = summDF.iplot(
        x=time_val,
        kind="scatter",
        y=yval,
        colors=[
            COLOR_STYLES["line_colors"][0],
        ],
        asFigure=True,
    )

    fig_layout = style_figure(fig["layout"], the_label)
    ##########################################################################################

    # Control Chart Figure
    ##########################################################################################
    flag_dict = data_styles
    for fkey in flag_dict:
        if fkey not in flag_checklist:
            flag_dict[fkey][1] = 0
        else:
            flag_dict[fkey][1] = 1

    # Control Chart Dataframe Analysis and Plotting
    conDF, segments = control_sort(summDF, yval, time_val, trend, deviation, flag_dict)
    controlFig = plot_control(conDF, segments, yval, time_val, all_trends, flag_dict)

    cFig_layout = style_figure(controlFig["layout"], the_label)
    ##########################################################################################

    # State-Space Chart Figure
    ##########################################################################################
    statespace_Fig = go.Figure()

    if chart_dropdown != "mean":
        # State-space specific Aggregation
        ###############################################################
        statespace_DF = subDF[[time_val, yval, lat_val, lon_val]]

        # If we just did median on an even length dataset, we would find the average between the two middle values
        # which often does not exist in the dataset. Knock the maximum value off the top of the dataset and grab the
        # now middle value.
        if chart_dropdown == "median":
            if len(vals) % 2 == 0:
                sorted_ss_DF = statespace_DF.sort_values(by=[yval], ascending=True)
                statespace_chart_DF = sorted_ss_DF.groupby(time_val).apply(
                    lambda x: x[x[yval] == x[yval].iloc[0:(int(len(x) - 1))].median()])
            else:
                statespace_chart_DF = statespace_DF.groupby(time_val).apply(lambda x: x[x[yval] == x[yval].median()])

        if chart_dropdown == "max":
            statespace_chart_DF = statespace_DF.groupby(time_val).apply(lambda x: x[x[yval] == x[yval].max()])

        if chart_dropdown == "min":
            statespace_chart_DF = statespace_DF.groupby(time_val).apply(lambda x: x[x[yval] == x[yval].min()])

        # State-space plotting
        ################################################################
        statespace_Fig.add_trace(go.Scatter(x=statespace_chart_DF[time_val],
                                            y=statespace_chart_DF[lat_val],
                                            mode='lines',
                                            name="Latitude", ))
        statespace_Fig.add_trace(go.Scatter(x=statespace_chart_DF[time_val],
                                            y=statespace_chart_DF[lon_val],
                                            mode='lines',
                                            name="Longitude", ))

    statespace_Fig_layout = style_figure(statespace_Fig["layout"], the_label)

    return fig, controlFig, statespace_Fig


# Update display for graph panel
@app.callback([
    Output("selected-control-data", "style"),
    Output("selected-statespace-data", "style"),
    Output("selected-data", "style"),
    Output("bottom-row", "style"),
    Output("controls-text", "style"),
    Output("aggregation-dropdown", "options"),
    Output("aggregation-dropdown", "value")
],
    [
        Input("chart-swapper", "value"),
        Input("aggregation-dropdown", "value")
    ],
    prevent_initial_call=True
)
def change_panel(chart_swapper, aggregation_dropdown):
    agg_opts = [
        {
            "label": "Mean Value",
            "value": "mean",
        },
        {
            "label": "Median Value",
            "value": "median",
        },
        {
            "label": "Min. Value",
            "value": "min",
        },
        {
            "label": "Max. Value ",
            "value": "max",
        },
    ]

    agg_val = aggregation_dropdown

    # Return Values:
    ##################################
    # Control Chart Visibility
    # State-Space Chart Visibility
    # Line Chart Visibility
    # Bottom Row Visibility
    # Controls Visibility
    # Aggregation Dropdown Options
    # Aggregation Dropdown Value
    ##################################
    if chart_swapper == "controlchart":
        return {'display': 'block'}, \
               {'display': 'none'}, \
               {'display': 'none'}, \
               {'display': 'flex'}, \
               {'display': 'flex'}, \
               agg_opts, \
               agg_val
    elif chart_swapper == "statespace":
        agg_opts.pop(0)
        if agg_val == "mean":
            agg_val == "median"
        return {'display': 'none'}, \
               {'display': 'block'}, \
               {'display': 'none'}, \
               {'display': 'none'}, \
               {'display': 'none'}, \
               agg_opts, \
               agg_val
    elif chart_swapper == "linechart":
        return {'display': 'none'}, \
               {'display': 'none'}, \
               {'display': 'block'}, \
               {'display': 'none'}, \
               {'display': 'none'}, \
               agg_opts, \
               agg_val


# Update Data Selection Dropdown
@app.callback([
    Output("data-dropdown", "options"),
    Output("data-dropdown", "value")
],
    [
        Input("dataframe-dropdown", "value")
    ]
)
def update_data_selector(dataframe_dropdown):
    dataOpts = []

    dataOpts = data_json_dict[dataframe_dropdown]['fields']
    dataValue = data_json_dict[dataframe_dropdown]['fields'][0]["value"]

    return dataOpts, dataValue


#######################################################################################################################


# Additional Helper Functions
#######################################################################################################################
# Style the chart figures for consistency
def style_figure(layout, title):
    fig_layout = layout

    # See plot.ly/python/reference
    fig_layout["yaxis"]["title"] = title
    fig_layout["xaxis"]["title"] = "Time (years)"
    fig_layout["yaxis"]["fixedrange"] = True
    fig_layout["xaxis"]["fixedrange"] = False
    fig_layout["hovermode"] = "closest"
    fig_layout["legend"] = dict(orientation="v")
    fig_layout["autosize"] = True
    fig_layout["paper_bgcolor"] = COLOR_STYLES["chart_background"]
    fig_layout["plot_bgcolor"] = COLOR_STYLES["chart_background"]
    fig_layout["font"]["color"] = COLOR_STYLES["font"]
    fig_layout["xaxis"]["tickfont"]["color"] = COLOR_STYLES["tick_font"]
    fig_layout["yaxis"]["tickfont"]["color"] = COLOR_STYLES["tick_font"]
    fig_layout["xaxis"]["gridcolor"] = COLOR_STYLES["chart_grid"]
    fig_layout["yaxis"]["gridcolor"] = COLOR_STYLES["chart_grid"]

    return fig_layout


# Function for selecting which dataframe to load when we need to load a dataframe into a callback.
#   - A line needs to be added here when adding a new dataframe to the dashboard.
def select_dataframe(dataframe_label):
    if dataframe_label == 'output.csv':
        return df_annual_climate
    elif dataframe_label == 'kestralModel.csv':
        return df_kestral_model
    elif dataframe_label == 'Carya_ovata.csv':
        return df_carya_ovata
    elif dataframe_label == 'carya_ovata_10km.csv':
        return df_carya_ovata_spacetime
    else:
        return pd.Dataframe()


#######################################################################################################################


# run the server
#######################################################################################################################
if __name__ == "__main__":
    app.run_server(debug=True)
